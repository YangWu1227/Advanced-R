---
title: "Application"
author: "Yang Wu"
date: "9/25/2021"
output:
  bookdown::html_document2:
    toc: true
    toc_float: true
    number_sections: false
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(comment = NA)
knitr::opts_chunk$set(warning = FALSE)
library(rlang)
options(digits = 4)
```

# Failure value

We can use a `tryCatch()` pattern that returns a default value if an error occurs:

```{r}
fail <- function(expr, value = NULL) {
  tryCatch(
    # Exiting handler that will catch the condition object generated by the error
    error = function(cnd) value,
    # Expression
    expr
  )
}
```

When `expr` succeeds:

```{r}
fail(expr = mean(1:10), value = NA_real_)
```

When `expr` fails:

```{r}
fail(expr = mean("1:10"), value = NA_real_)
```

---

Another application is `base::try()` which is a wrapper to run an expression that might fail and allow the user's code to handle error-recovery:

```{r}
try2 <- function(expr, silent = FALSE) {
  tryCatch(
    # Exiting handler
    error = function(cnd) {
      # First capture the condition message from the condition object generated by the failing expr
      msg <- conditionMessage(cnd)
      # If silent is FALSE, then print a message "Error: msg"
      if (!silent) {
        message("Error: ", msg)
      }
      # Attach class "try-error" to the message
      base::structure(.Data = msg, class = "try-error")
    },
    # When this expression signals a condition, control passes to the handler and never returns again
    expr
  )
}
```

The function `base::structure(.Data, ...)` returns the given object with further attributes set. The variable argument `...` are attributes, specified in `tag = value` form, which will be attached to data.

```{r}
base::structure(.Data = fail, class = "try-error")
```

Let us see `try2()` in action:

```{r}
# Even when expr fails, the message in stop() is captured and an error message is printed
try2(expr = stop("This failed"))
try2(expr = stop("This failed"), silent = TRUE)
```

---

# Success and failure values

A useful pattern is to return a value if the code evaluates successfully but another value if it fails.

```{r, eval=FALSE}
fail2 <- function(expr) {
  tryCatch(
    # Handler
    error = function(cnd) failture_value,
    {
      # If expr signals a condition then control is passed to the handler function
      expr
      # If expr signals a condition then success_val is never run since control never returns to it
      success_val
    }
  )
}
```

Let us see it in action. For instance, we can use to to determine if an expression fails:

```{r}
does_error <- function(expr) {
  tryCatch(
    error = function(cnd) TRUE,
    {
      expr
      FALSE
    }
  )
}
# Test
does_error(expr = log("3"))
does_error(expr = log(3))
```

---

We could use it to capture any condition, similar to `rlang::catch_cnd()`:

```{r}
catch_cnd <- function(expr) {
  tryCatch(
    condition = function(cnd) cnd,
    {
      expr
      NULL
    }
  )
}
# Test
catch_cnd(expr = log(3))
catch_cnd(expr = log("3"))
```

---

Another application is to use it to modify `try()`, allowing it to tell us whether or not the code succeeded.

```{r}
safety <- function(expr) {
  tryCatch(
    # Handler
    error = function(cnd) {
      # Return a list that contains the results, which is unsuccessful, and the error condition object
      list(result = NULL, error = cnd)
    },
    # If expr evaluates successfully, then a list is returned with expr and the error which is NULL
    list(result = expr, error = NULL)
  )
}
```

This is closed related to `purrr::safely()`, which is a function operator:

```{r}
str(safety(1 + 10))
str(safety(stop("Error!")))
```

---

# Re-signal

We could use handlers to re-signal warnings to errors. Hadley believes that many warnings in base R would be better as errors, which forces users to confront them rather than ignore them.

```{r}
warning_to_error <- function(expr) {
  withCallingHandlers(
    # The calling handler is matched with the condition that expr signals
    # However, we abort() to effectively turn the warning into an error
    warning = function(cnd) abort(conditionMessage(cnd)),
    # When expr signals a condition object with class attribute "simpleWarning" "warning" "condition"
    # Control will be passed to the calling handler, which abort()
    # Therefore, expr is never run if it signals a warning condition object
    expr
  )
}
```

Let us see it in action:

```{r, eval=FALSE}
warning_to_error({
  x <- 2^4
  warn("Hello")
})
# Error: Hello Run `rlang::last_error()` to see where the error occurred.
```



















